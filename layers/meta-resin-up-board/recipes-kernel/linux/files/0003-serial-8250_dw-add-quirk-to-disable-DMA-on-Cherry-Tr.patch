From 838ab9f3d3d2ced7576c905000ef6b2bce83ef67 Mon Sep 17 00:00:00 2001
From: Dan O'Donovan <dan@emutex.com>
Date: Fri, 17 Mar 2017 00:21:38 +0000
Subject: [PATCH 03/10] serial: 8250_dw: add quirk to disable DMA on Cherry
 Trail SoC

Using DMA with the HS-UART on the Atom X5-8350 "Cherry Trail" SoC
results in data loss/corruption on UART transfers and the following
error message filling the kernel log:
  "serial8250: too much work for irq39"

As a temporary workaround, this commit disables use of DMA for the
HS-UARTs on Cherry Trail (matching ACPI device ID "8086228A").

Signed-off-by: Dan O'Donovan <dan@emutex.com>

Upstream-Status: Pending
Signed-off-by: Florin Sarbu <florin@resin.io>
---
 drivers/tty/serial/8250/8250_dw.c | 21 ++++++++++++++-------
 1 file changed, 14 insertions(+), 7 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 5ebf984..f4c067d 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -70,6 +70,7 @@ struct dw8250_data {
 
 	unsigned int		skip_autocfg:1;
 	unsigned int		uart_16550_compatible:1;
+	unsigned int		skip_dma:1;
 };
 
 static inline int dw8250_modify_msr(struct uart_port *p, int offset, int value)
@@ -350,16 +351,22 @@ static void dw8250_quirks(struct uart_port *p, struct dw8250_data *data)
 
 		id = acpi_match_device(p->dev->driver->acpi_match_table,
 				       p->dev);
-		if (id && !strcmp(id->id, "APMC0D08")) {
-			p->iotype = UPIO_MEM32;
-			p->regshift = 2;
-			p->serial_in = dw8250_serial_in32;
-			data->uart_16550_compatible = true;
+		if (id) {
+			if (!strcmp(id->id, "APMC0D08")) {
+				p->iotype = UPIO_MEM32;
+				p->regshift = 2;
+				p->serial_in = dw8250_serial_in32;
+				data->uart_16550_compatible = true;
+			} else if (!strcmp(id->id, "8086228A")) {
+				data->skip_dma = true;
+			}
 		}
 	}
 
 	/* Platforms with iDMA */
-	if (platform_get_resource_byname(to_platform_device(p->dev),
+	if (!data->skip_dma &&
+	    platform_get_resource_byname(to_platform_device(p->dev),
+
 					 IORESOURCE_MEM, "lpss_priv")) {
 		data->dma.rx_param = p->dev->parent;
 		data->dma.tx_param = p->dev->parent;
@@ -549,7 +556,7 @@ static int dw8250_probe(struct platform_device *pdev)
 		dw8250_setup_port(p);
 
 	/* If we have a valid fifosize, try hooking up DMA */
-	if (p->fifosize) {
+	if (!data->skip_dma && p->fifosize) {
 		data->dma.rxconf.src_maxburst = p->fifosize / 4;
 		data->dma.txconf.dst_maxburst = p->fifosize / 4;
 		uart.dma = &data->dma;
-- 
2.7.4

